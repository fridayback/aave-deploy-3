{
  "address": "0x47Dbb7BD78280198e59A67141294E084Ef47d842",
  "abi": [],
  "transactionHash": "0xe3ca7747830c9b77d90245e204446566ae5630ba7f353c049bc930351817b844",
  "receipt": {
    "to": null,
    "from": "0xe26e32F138f9a6f29432D47AfC98ef77b189A8F8",
    "contractAddress": "0x47Dbb7BD78280198e59A67141294E084Ef47d842",
    "transactionIndex": 0,
    "gasUsed": "72217",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2f2a8194f633c9c45d8102f5f97b0502842290b79f2bf56c59799fa037cc174a",
    "transactionHash": "0xe3ca7747830c9b77d90245e204446566ae5630ba7f353c049bc930351817b844",
    "logs": [],
    "blockNumber": 9906735,
    "cumulativeGasUsed": "72217",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "859a23405950d1edc8948f26899cd37c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"author\":\"Aave\",\"kind\":\"dev\",\"methods\":{},\"title\":\"CalldataLogic library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/libraries/logic/CalldataLogic.sol\":\"CalldataLogic\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/protocol/libraries/logic/CalldataLogic.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.10;\\n\\n/**\\n * @title CalldataLogic library\\n * @author Aave\\n * @notice Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction\\n */\\nlibrary CalldataLogic {\\n  /**\\n   * @notice Decodes compressed supply params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed supply params\\n   * @return The address of the underlying reserve\\n   * @return The amount to supply\\n   * @return The referralCode\\n   */\\n  function decodeSupplyParams(mapping(uint256 => address) storage reservesList, bytes32 args)\\n    internal\\n    view\\n    returns (\\n      address,\\n      uint256,\\n      uint16\\n    )\\n  {\\n    uint16 assetId;\\n    uint256 amount;\\n    uint16 referralCode;\\n\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      referralCode := and(shr(144, args), 0xFFFF)\\n    }\\n    return (reservesList[assetId], amount, referralCode);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed supply params to standard params along with permit params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed supply with permit params\\n   * @return The address of the underlying reserve\\n   * @return The amount to supply\\n   * @return The referralCode\\n   * @return The deadline of the permit\\n   * @return The V value of the permit signature\\n   */\\n  function decodeSupplyWithPermitParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  )\\n    internal\\n    view\\n    returns (\\n      address,\\n      uint256,\\n      uint16,\\n      uint256,\\n      uint8\\n    )\\n  {\\n    uint256 deadline;\\n    uint8 permitV;\\n\\n    assembly {\\n      deadline := and(shr(160, args), 0xFFFFFFFF)\\n      permitV := and(shr(192, args), 0xFF)\\n    }\\n    (address asset, uint256 amount, uint16 referralCode) = decodeSupplyParams(reservesList, args);\\n\\n    return (asset, amount, referralCode, deadline, permitV);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed withdraw params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed withdraw params\\n   * @return The address of the underlying reserve\\n   * @return The amount to withdraw\\n   */\\n  function decodeWithdrawParams(mapping(uint256 => address) storage reservesList, bytes32 args)\\n    internal\\n    view\\n    returns (address, uint256)\\n  {\\n    uint16 assetId;\\n    uint256 amount;\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n    }\\n    if (amount == type(uint128).max) {\\n      amount = type(uint256).max;\\n    }\\n    return (reservesList[assetId], amount);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed borrow params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed borrow params\\n   * @return The address of the underlying reserve\\n   * @return The amount to borrow\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\n   * @return The referralCode\\n   */\\n  function decodeBorrowParams(mapping(uint256 => address) storage reservesList, bytes32 args)\\n    internal\\n    view\\n    returns (\\n      address,\\n      uint256,\\n      uint256,\\n      uint16\\n    )\\n  {\\n    uint16 assetId;\\n    uint256 amount;\\n    uint256 interestRateMode;\\n    uint16 referralCode;\\n\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      interestRateMode := and(shr(144, args), 0xFF)\\n      referralCode := and(shr(152, args), 0xFFFF)\\n    }\\n\\n    return (reservesList[assetId], amount, interestRateMode, referralCode);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed repay params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed repay params\\n   * @return The address of the underlying reserve\\n   * @return The amount to repay\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\n   */\\n  function decodeRepayParams(mapping(uint256 => address) storage reservesList, bytes32 args)\\n    internal\\n    view\\n    returns (\\n      address,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint16 assetId;\\n    uint256 amount;\\n    uint256 interestRateMode;\\n\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      interestRateMode := and(shr(144, args), 0xFF)\\n    }\\n\\n    if (amount == type(uint128).max) {\\n      amount = type(uint256).max;\\n    }\\n\\n    return (reservesList[assetId], amount, interestRateMode);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed repay params to standard params along with permit params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed repay with permit params\\n   * @return The address of the underlying reserve\\n   * @return The amount to repay\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\n   * @return The deadline of the permit\\n   * @return The V value of the permit signature\\n   */\\n  function decodeRepayWithPermitParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  )\\n    internal\\n    view\\n    returns (\\n      address,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint8\\n    )\\n  {\\n    uint256 deadline;\\n    uint8 permitV;\\n\\n    (address asset, uint256 amount, uint256 interestRateMode) = decodeRepayParams(\\n      reservesList,\\n      args\\n    );\\n\\n    assembly {\\n      deadline := and(shr(152, args), 0xFFFFFFFF)\\n      permitV := and(shr(184, args), 0xFF)\\n    }\\n\\n    return (asset, amount, interestRateMode, deadline, permitV);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed swap borrow rate mode params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed swap borrow rate mode params\\n   * @return The address of the underlying reserve\\n   * @return The interest rate mode, 1 for stable 2 for variable debt\\n   */\\n  function decodeSwapBorrowRateModeParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, uint256) {\\n    uint16 assetId;\\n    uint256 interestRateMode;\\n\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      interestRateMode := and(shr(16, args), 0xFF)\\n    }\\n\\n    return (reservesList[assetId], interestRateMode);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed rebalance stable borrow rate params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed rabalance stable borrow rate params\\n   * @return The address of the underlying reserve\\n   * @return The address of the user to rebalance\\n   */\\n  function decodeRebalanceStableBorrowRateParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, address) {\\n    uint16 assetId;\\n    address user;\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      user := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n    }\\n    return (reservesList[assetId], user);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed set user use reserve as collateral params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed set user use reserve as collateral params\\n   * @return The address of the underlying reserve\\n   * @return True if to set using as collateral, false otherwise\\n   */\\n  function decodeSetUserUseReserveAsCollateralParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, bool) {\\n    uint16 assetId;\\n    bool useAsCollateral;\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      useAsCollateral := and(shr(16, args), 0x1)\\n    }\\n    return (reservesList[assetId], useAsCollateral);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed liquidation call params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args1 The first half of packed liquidation call params\\n   * @param args2 The second half of the packed liquidation call params\\n   * @return The address of the underlying collateral asset\\n   * @return The address of the underlying debt asset\\n   * @return The address of the user to liquidate\\n   * @return The amount of debt to cover\\n   * @return True if receiving aTokens, false otherwise\\n   */\\n  function decodeLiquidationCallParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args1,\\n    bytes32 args2\\n  )\\n    internal\\n    view\\n    returns (\\n      address,\\n      address,\\n      address,\\n      uint256,\\n      bool\\n    )\\n  {\\n    uint16 collateralAssetId;\\n    uint16 debtAssetId;\\n    address user;\\n    uint256 debtToCover;\\n    bool receiveAToken;\\n\\n    assembly {\\n      collateralAssetId := and(args1, 0xFFFF)\\n      debtAssetId := and(shr(16, args1), 0xFFFF)\\n      user := and(shr(32, args1), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n\\n      debtToCover := and(args2, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      receiveAToken := and(shr(128, args2), 0x1)\\n    }\\n\\n    if (debtToCover == type(uint128).max) {\\n      debtToCover = type(uint256).max;\\n    }\\n\\n    return (\\n      reservesList[collateralAssetId],\\n      reservesList[debtAssetId],\\n      user,\\n      debtToCover,\\n      receiveAToken\\n    );\\n  }\\n}\\n\",\"keccak256\":\"0xa0db9d178eae76e386152d44957a9e2344e16921b381ccb74a4fa4d83f0757bf\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212202aab8de9daa667bf87af55dc6368410d2038621b756c9328eceb994853da90fb64736f6c634300080a0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212202aab8de9daa667bf87af55dc6368410d2038621b756c9328eceb994853da90fb64736f6c634300080a0033",
  "devdoc": {
    "author": "Aave",
    "kind": "dev",
    "methods": {},
    "title": "CalldataLogic library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}